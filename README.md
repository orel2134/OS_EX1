שאלה 1:
![image](https://github.com/user-attachments/assets/e866be75-9e3e-4a39-b058-02e3d9905844)


הפקודה make all מריצה את הקימפול עבור כל 6 הגרסאות: bad_prog_1/2/3 ו־bad_prog_1_g/2_g/3_g.
עבור bad_prog_1.c, מוצגת אזהרת רקורסיה אינסופית – בדיוק כמצופה מהדרישה לממש תוכנית שגורמת ל־stack overflow.
אין שגיאות קימפול, כלומר כל הקבצים נבנו בהצלחה.                                                 וזה מוכיח כי התוכניות קיימות, מקומפלות כמו שצריך, ועומדות בדרישות של יצירת גרסאות עם וללא debug info.
האזהרות תואמות את הבאגים שנדרשו (למשל רקורסיה בלתי נגמרת), ולכן ההרצה עונה במדויק על דרישת המטלה.





שאלה 2:

בתמונה זו אנו רואים הרצה של הפונקציה בשם mandelbrot, אשר בודקת האם מספר מרוכב שייך לקבוצת מנדלברוט.
למשל, ההרצה ./mandelbrot -1.627 -0.001 בודקת אם המספר −1.627−0.001i-1.627 - 0.001i−1.627−0.001i שייך לקבוצה, והפלט מאשר שהוא כן שייך וכן עוד כמה דוגמאות שעשינו כך שפלט הפונקציה הוא כנדרש במטלה.
הרצות נוספות כמו ./mandelbrot 1 1 מראות שהמספר  לא שייך לקבוצה.
לבסוף, מוצגת גם הודעת שימוש כשהפקודה מופעלת ללא ארגומנטים.

שאלה 3:

בתמונה מוצגת הדגמה של הרצת תוכנית מתוך שאלה 3 בתרגיל, אשר בודקת האם מספר מרוכב שייך לקבוצת מנדלברוט באמצעות ספרייה דינמית. בתחילה מבוצעת קומפילציה באמצעות הפקודה make, אשר יוצרת את הקובץ libmandelbrot.so (הספרייה הדינמית) מתוך הקובץ mandelbrot.c, ולאחר מכן מקמפלת את הקובץ main.c תוך קישור מול אותה ספרייה. ההרצה עצמה נעשית עם הגדרת המשתנה LD_LIBRARY_PATH=. כדי שהמערכת תדע לאתר את הספרייה הדינמית בתיקייה הנוכחית.
הפונקציה המרכזית שממומשת ונבדקת כאן היא is_in_mandelbrot(complex double c, int N) אשר מקבלת מספר מרוכב ובודקת האם הוא שייך לקבוצת מנדלברוט. הקלט מתקבל מהמשתמש דרך scanf, ובדוגמה שבתמונה המספר שהוזן הוא ‎-1.627 + -0.001i‎.
הפלט שקיבלנו- 
-1.627 + -0.001i is in the Mandelbrot set
מראה לנו שהקריאה לספרייה הדינמית הצליחה, הקלט נקלט כראוי, והפונקציה פעלה באופן תקין והחזירה תוצאה נכונה.




שאלה 4:



בתרגיל זה, הקובץ main.c מקומפל עם הדגלים -fprofile-arcs -ftest-coverage, שמיועדים לאיסוף מידע עבור כיסוי קוד (Code Coverage). כתוצאה מכך מתקבלים הקובץ main וכן קבצים נלווים כמו .gcno הדרושים לניתוח כיסוי בעזרת gcov.
לאחר הקימפול, מתבצעת הרצה של הקוד באמצעות make run: תחילה עם קלט תקין (good_input.txt), ולאחר מכן עם מספר קבצי קלט שגויים (bad_input*.txt). כל ההרצות מתבצעות ללא הדפסת פלט למסך (> /dev/null) – המטרה היא רק לאסוף נתוני כיסוי.
בהמשך מופעלת הפקודה gcov main.c, אשר מחשבת את אחוז שורות הקוד שבוצעו בפועל. הפלט שהתקבל:
Lines executed:100.00% of 78
מציין שכל 78 שורות הקוד בתוכנית הופעלו לפחות פעם אחת במהלך ההרצות.                              כך אנו רואים שהשאלה בוצעה בהצלחה – הדרישה הייתה להריץ עם קלטים תקינים ושגויים    ולוודא שכיסוי הקוד מלא. יצירת הקובץ main.c.gcov והצגת פלט של 100% הרצה מעידים שהיעד הזה הושג כראוי.
שאלה 5:



בתמונה זו אנו רואים הרצה מוצלחת של שאלה 5 בתרגיל, שמטרתה להשוות בין שלוש גרסאות של אלגוריתם למציאת תת־מערך מירבי: ב־O(n), O(n²), ו־O(n³), תוך שימוש בכלי gprof לניתוח ביצועים.
כיצד זה מבוצע? - תחילה מבוצעת קומפילציה של שלושת הקבצים (main1, main2, main3) עם הדגל ‎-pg‎, שמאפשר איסוף מידע פרופילאי ל־gprof. כל אחת מהגרסאות משתמשת במימוש שונה של האלגוריתם, בהתאם לסיבוכיות הרצויה.                                     בהמשך, באמצעות הפקודה make run, כל גרסה מורצת עם אותם ערכי קלט (SEED = 5, N = 100). הריצה יוצרת קובץ ביצועים בשם gmon.out, אשר מועתק לכל גרסה לקובץ נפרד בתיקיית gmon_outputs.
לאחר כל הרצה, מופעל הכלי gprof שמנתח את הביצועים של הגרסה שהורצה. תוצאות הניתוח (בפורמט flat-profile) מתווספות לקובץ output100.txt, כך שבסוף מתקבל מסמך שמכיל השוואה בין שלוש הגרסאות מבחינת זמן ריצה והתנהגות פנימית.
וזה עונה על דרישות המטלה בכך: הדרישות כללו קימפול עם ‎-pg‎, הרצת שלוש גרסאות האלגוריתם, ניתוח הביצועים עם gprof, ותיעוד התוצאות בקובץ השוואתי. הפלט שבתמונה מוכיח שכל שלב בתהליך בוצע כהלכה:
שלושת הקבצים קומפלו עם הדגלים הנדרשים.


שלוש הריצות בוצעו והפיקו קבצי gmon.out שונים.


פלט הביצועים נכתב לקובץ output100.txt באופן מסודר.


שאלה 6:





בשתי התמונות אנו רואים הדגמה של הרצת שאלה 6 בתרגיל, שמטרתה לממש תקשורת בין שני תהליכים באמצעות אותות (signals). ולאחר מכן קומפילציה של שני הקבצים: signal_receiver.c ו־signal_sender.c, אשר יוצרים את הקבצים הבינאריים signal_receiver ו־signal_sender. מופיעה אזהרה לגבי הפונקציה usleep, אך הקוד ממשיך להיקמפל. לאחר מכן מופעל המקלט (receiver) באמצעות make run_receiver, והוא מדפיס את ה־PID שלו וממתין לקבלת מסר.
בתמונה השנייה נפתח טרמינל חדש, שבו מופעל המשדר (sender) באמצעות make run_sender. המשתמש מזין את ה־PID של המקלט ואת ההודעה (42). ההודעה נשלחת ביט־ביט באמצעות SIGUSR1 ו־SIGUSR2, והמקלט מדפיס את ההודעה שהתקבלה במלואה – "Received 42".


שאלה 7:



בתמונה זו אנו רואים הדגמה מוצלחת של שאלה 7 בתרגיל, אשר עוסקת בשימוש בפורק והרצת תוכניות שונות (add2PB ו־findPhone) תוך תקשורת דרך קובץ משותף — ממש בדומה למערכת של ניהול אנשי קשר.
 שלבי ההרצה:
הרצה ראשונה של ./findPhone Daniel:
 בשלב זה, הקובץ עוד לא הכיל את השם "Daniel", ולכן לא הוחזר פלט — כצפוי.


הרצה של ./add2PB Daniel 0541234567:
 כאן מתבצעת הוספת זוג נתונים — שם ומספר טלפון — לרשימת אנשי הקשר. הפקודה מבצעת כנראה כתיבה לקובץ טקסט כלשהו.


הרצה נוספת של ./findPhone Daniel:
 כעת, לאחר ההוספה, מתקבל הפלט:
 Daniel 0541234567
 כלומר: הקריאה לקובץ הצליחה, והנתונים אותרו ונשלפו בהצלחה.


 וזה עונה על דרישות המטלה - התרגיל דרש שימוש ב־fork, exec ו־wait כדי לבנות מערכת שמבצעת פעולות שונות כמו הוספה וחיפוש ברשומה.
הפקודות בתמונה מראות שהקוד מתנהג כמצופה: ניתן להוסיף נתון חדש לקובץ, ולאחר מכן לחפש ולשלוף אותו.


השימוש בתוכניות נפרדות (add2PB, findPhone) מראה חלוקה הגיונית לתהליכים, כמתבקש בשאלה.



